\chapter{Conclusion}
In this thesis we have investigated traditional and innovative architectural principles for modern Web applications. We defined a Web app as a traditional Web 2.0 application that includes highly interactive behavior, social networking features, and large quantities of persisted data. The problem statement concerns architectural alternatives for implementing such applications. It asks the question of wether the application can benefit on doing HTML rendering on the client, and if there are advantages for moving business logic and state handling to the client. The motivation for this is new improvement in JavaScript engines in modern browsers, which enables more complex JavaScript executions on the client. Also, the problem statement addresses modern database solutions called NoSQL, and asks wether there are any such database that suits the JavaScript-oriented Web application.

In order to solve this, we defined two reference-models; \textit{Reference-model 1.0} and \textit{Reference-model 2.0}. These addresses principles for a traditional thin-client Web application architecture, and a modern and innovative thick-client architecture, respectively. \textit{Reference-model 1.0} states that all application processing happens on the server, including state handling, business logic and page rendering. In addition, the data is persisted with a relational database. \textit{Reference-model 2.0} states that these concerns are now completely implemented on the client, using JavaScript. In addition, the data is persisted by using suitable NoSQL database technologies. 

The principles for \textit{Reference-model 1.0} and \textit{Reference-model 2.0} were applied in the implementation of two different architectures that solves the same problem domain; a Web app called Shredhub. These two architectures were respectively called \textit{Architecture 1.0} and \textit{Architecture 2.0}. In order to solve the problem statement, a set of five extensive test cases were designed and performed on these architectures. 

% HTML rendering
The results showed that rendering HTML on the client is fully feasible, by fetching all the necessary HTML to the browser on the initial Web app request. Client-side JavaScript code is especially customized to render only the HTML that is needed for every subsequent request. This resulted in less page rendering and fewer server requests, which successfully lead to less load on the server, and thus both faster response-times and better scalability was achieved for Architecture 2.0. Better scalability on back-end was also achieved because the amount of work done on the server per request is very limited. A problem however, was that the initial page load was very slow, because a large JavaScript application had to be fetched from the server. 

One obvious programming benefit came clear for Architecture 2.0. It was easier to separate the user-interface logic out of the HTML templates, because this logic is implemented in the same language as the business-logic. Therefore, the user-interface logic and business logic that concerns the same domain, could be implemented under the same module, and thus cooperate better.  

% State biz on client
The tests also showed that moving state and business logic to the client had large performance and scalability gains. The front-end could avoid consulting the server, and when it did, the server merely had to query the database and send small-sized fine-grained data objects back. The results were that the front-end had very quick response times for user actions, and much work was relieved from the server. This led to higher scalability, where many more concurrent users could be served than in the other approach. A pitfall here is that Architecture 2.0 does require an efficient browser and client machine to run efficiently. Another disadvantage is that some business rules has to be implemented both on the client and the server. However, we proposed a hybrid solution for a future study, where when building pure JavaScript Web apps, the code-base might be able to be shared on both the client and the server, thus avoiding the need to duplicate. 

% Mongo SQL
As for the databases, both SQL and NoSQL had their advantages. SQL were slow in cases were many join operations were needed. MongoDB could be implemented in a way that avoids the need to join, by having fat objects that contain all the necessary data most queries require. However, once multiple objects had to be joined together, MongoDB could be significantly slow. Another advantage with using MongoDB in Architecture 2.0 was that no marshalling of data was needed to communicate with the database. This is a big programming benefit, because it reduces the size of the code base, and simplifies working with the database. In addition, the flexible NoSQL database allows for the domain to be persisted exactly as it looks like in the user-interface. This very much simplifies query implementations. We also saw that Redis could be used to support the stateless server, by quickly authenticating every HTTP request. Architecture 1.0 uses server-side sessions to maintain authentication through an HTTP session, something that can lead to slow response times because the sessions consumes a lot of memory. Avoiding this with Redis had great performance results for Architecture 2.0, and it facilitates replicating the back-end because the client and server is now much more decoupled.


%In this thesis I have been comparing various software architectures for web applications that has a rich and interactive web interface and that has high demands for scalability and responsivity. The application has many of the requirements that is normally seen in a modern web application, like interactivity and user participation. Also, the application should be able to offer its functionality as a software-as-a-service. 
%
%The goal for the project was to find a software architecture that would best succeed in delivering these requirements. Therefore, I chose to start out with designing a classical three-layered architecture that has been regarded as the best-practice web architecture for the last decades in the web community. However, seen that the classical way for building web apps has seen a paradigm shift with the rise of "web 2.0" I wanted to compare this design with a more modern thick-client web architecture. Both designs where built with the same goal, and they where both optimized in their separate, best suited way. Finally a comparison job was introduced to find the pros and cons for each design. 
%
%When comparing the designs, performance was the common goal. The architecture had to deliver its service as efficient as possible. I verified the scalability behavior when more and more requests where fired at the server. The responsivity was tested by actively requesting various resources and measuring the response time. Good results where given by using appropriate testing tools that created dummy requests and flooded the application with requests, both directly to the backend and also through the user interface. This way I got separate tests for the database, the server api implementation, as well as the front-end implementation. Finally the I wanted to see how well the two architectures worked when they where deployed in a cloud environment. The cloud service distributed the application to multiple servers, which has a big impact on how the application performs. The same tests where run on both applications and the results where compared. A final goal with the designs was targeted against the source code itself. Not only was it important that the application performed well, but the software architecture had to be maintainable. Therefore, I compared how the various source codes turned out to be in terms of, flexibility and complexity.  
%
%The result was that architecture 1.0 had a very efficient database implementation when run locally, but the front-end became a bottleneck due to the high amount of data returned for each request. This was expected, because the server always responded with a complete HTML page. When introducing a noSQL database for architecture 1.0, I got lower efficiency. However when I deployed architecture 1.0 in the cloud, the system worked better with the noSQL database. It could tolerate many more requests then the postgreSQL implementation. This is probably because cloud environments are optimized to perform well with noSQL databases.
% 
%Architecture 2.0 did not achieve the same database performance when run locally as architecture 1.0. However, the front-end was much more responsive. This was clearly because the amount of data sent back from the server where much less then with architecture 1.0. Also, the amounts of HTTP requests where reduced with architecture 2.0, which was a result of the javascript MVC front-end architecture. When architecture 2.0 was deployed in the cloud, it got better performance results then with architecture 1.0, both in terms of scalability and response time for independent requests. 
%I will conclude with stating the architecture 1.0 performed better then architecture 2.0 when deployed locally, and with a small number of simultaneous users. Architecture 2.0 performed best when deployed in the cloud, and achieved higher performance in both scenarios, when the number of users where many.
%
%When it came to code flexibility and complexity, architecture 2.0 had a more compact design, because most of the source code lies in the frond-end. Even so, the code structure was nice and decoupled with intuitive responsibilities and object abstractions. This was a clear improvement from application 1.0, because in this design the front-end code was very complex and lacked code structure. Design patterns weren't even an option in the latter approach, because the way the javascript code used was only as separate functions with no object reuse. In architecture 2.0 however, I could often find places where design patterns had a natural fit. The only pitfall I can see with architecture 2.0 is that the source code is for many developers who are not very familiar with javascript difficult to understand, since the language (which is referred to as a functional-oriented language) is very different from an object-oriented language like java or c++. 
%I will conclude by stating the architecture 2.0 had a flexible and less complex code structure then architecture 1.0, because the application required many dynamic and interactive GUI components. This is better to implement with a thick-client javascript MVC architecture, then with a java-based thin-client architecture with a template language like JSP. Also, noSQL databases works very good with a javascript architecture, because of syntax similarities. 
%
%When it comes to being able to deliver application service to third party clients and mobile applications, architecture 2.0 already had this enabled through a restful server API. Architecture 1.0 did not have this, so to enable it, I had to implement separate controllers on the web tier that would check each request to see if they where not from a web user, the server would respond with the appropriate data-format (like JSON or XML). This resulted in lots of controller handlers, but a flexible solution if one would require support for both HTML page responses and xml/jSON responses.  